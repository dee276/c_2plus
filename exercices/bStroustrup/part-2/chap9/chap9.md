### Statements

C++ offers a conventional and flexible set of statements. Basically all that is either interesting or
complicated is found in expressions and declarations. Note that a declaration is a statement and
that an expression becomes a statement when you add a semicolon at its end.
Unlike an expression, a statement does not have a value. Instead, statements are used to specify
the order of execution. For example:
a = b+c; // expression statement
if (a==7) // if-statement
b = 9; // execute if and only if a==9

#### Statements summary

Statement Summary
Here is a summary of C++ statements:
statement:
declaration
expressionopt ;
{ statement-listopt }
try { statement-listopt } handler-list
case constant-expression : statement
default : statement
break ;
continue ;
return expressionopt ;
goto identifier ;
identifier : statement
selection-statement
iteration-statement
selection-statement:
if ( condition ) statement
if ( condition ) statement else statement
switch ( condition ) statement
iteration-statement:
while ( condition ) statement
do statement while ( expression ) ;
for ( for-init-statement conditionopt ; expressionopt ) statement
for ( for-init-declaration : expression ) statement

#### Switch statemens

switch Statements
A switch-statement selects among a set of alternatives (case-labels). The expression in the case
labels must be a constant expression of integral or enumeration type. A value may not be used
more than once for case-labels in a switch-statement. For example:

switch (val) {
case 1:
f();
break;
case 2:
g();
break;
default:
h();
break;
}

#### Iteration Statements

**Range-for Statements**
The simplest loop is a range-for-statement; it simply gives the programmer access to each element
of a range. For example:

int sum(vector<int>& v)
{
int s = 0;
for (int x : v)
s+=x;
return s;
}

The for (int x : v) can be read as ‘‘for each element x in the range v’’ or just ‘‘for each x in v.’’ The
elements of v are visited in order from the first to the last.

The expression after the colon must denote a sequence (a range); that is, it must yield a value
for which we can call v.begin() and v.end() or begin(v) and end(v) to obtain an iterators:
[1] the compiler first looks for members begin and end and tries to use those. If a begin or an
end is found that cannot be used as a range (e.g., because a member begin is a variable
rather than a function), the range-for is an error.
[2] Otherwise, the compiler looks for a begin/end member pair in the enclosing scope. If
none is found or if what is found cannot be used (e.g., because the begin did not take an
argument of the sequence’s type), the range-for is an error.
The compiler uses v and v+N as begin(v) and end(v) for a built-in array T v[N]. The <iterator> header
provides begin(c) and end(c) for built-in arrays and for all standard-library containers. For
sequences of our own design, we can define begin() and end() in the same way as it is done for standard-library containers.

**for Statements**
There is also a more general for-statement allowing greater control of the iteration. The loop variable, the termination condition, and the expression that updates the loop variable are explicitly presented ‘‘up front’’ on a single line. For example:

void f(int v[], int max)
{
for (int i = 0; i!=max; ++i)
v[i] = i∗i;
}

It is not always obvious what is the right type to use for a controlled variable in a for loop, so
auto often comes in handy:

for (auto p = begin(c); c!=end(c); ++p) {
// ... use iterator p for elements in container c ...
}

**while Statements**
A while-statement executes its controlled statement until its condition becomes false. For example:
template<class Iter, class Value>
Iter find(Iter first, Iter last, Value val)
{
while (first!=last && ∗first!=val)
++first;
return first;
}

**do Statements**
A do-statement is similar to a while-statement except that the condition comes after the body. For
example:
void print_backwards(char a[], int i) // i must be positive
{
cout << '{';
do {
cout << a[−−i];
} while (i);
cout << '}';
}

#### goto Statements
C++ possesses the infamous goto:

goto identifier ;
identifier : statement

The goto has few uses in general high-level programming, but it can be very useful when C++ code
is generated by a program rather than written directly by a person; for example, gotos can be used
in a parser generated from a grammar by a parser generator.

The scope of a label is the function it is in. This implies that you can use goto to jump
both into and out of blocks. The only restriction is that you cannot jump past an initializer or into
an exception handler.

One of the few sensible uses of goto in ordinary code is to break out from a nested loop or
switch-statement (a break breaks out of only the innermost enclosing loop or switch-statement). For
example:

void do_something(int i, int j)
// do something to a two-dimensional matrix called mn
{
for (i = 0; i!=n; ++i)
for (j = 0; j!=m; ++j)
if (nm[i][j] == a)
goto found;
// not found
// ...
found:
// nm[i][j] == a
}

#### Advice
[1] Don’t declare a variable until you have a value to initialize it with; §9.3, §9.4.3, §9.5.2.
[2] Prefer a switch-statement to an if-statement when there is a choice; §9.4.2.
[3] Prefer a range-for-statement to a for-statement when there is a choice; §9.5.1.
[4] Prefer a for-statement to a while-statement when there is an obvious loop variable; §9.5.2.
[5] Prefer a while-statement to a for-statement when there is no obvious loop variable; §9.5.3.
[6] Avoid do-statements; §9.5.
[7] Avoid goto; §9.6.
[8] Keep comments crisp; §9.7.
[9] Don’t say in comments what can be clearly stated in code; §9.7.
[10] State intent in comments; §9.7.
[11] Maintain a consistent indentation style; §9.7.